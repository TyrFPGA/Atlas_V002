# 8253 - プログラマブル・インターバル・タイマ

## 注意
このドキュメントは英語が苦手な私が、拙速に参照するために作成したものです。基本的には原本(英語)を見ながら使用します。

変な表現や間違った訳が存在しており、いくつかは認識しています。基本的に修正する予定はありません。

8253を設計する方は、ほとんどの場合はオリジナルを参照した方が効率的でしょう。

## 機能説明

### 概要

8253はマイクロプロセッサの周辺装置として使用するために設計されたプログラム可能なカウンタ/タイマデバイスである。
このデバイスは、3つの独立した16ビットカウンタを持ち、それぞれは最大2.6MHzのレートでカウントする。
すべての制御モードはソフトウェアによってプログラムできる。

8253はどのマイクロプロセッサにもあるごくありふれた一つの問題を解決する。
それはソフトウェア制御による正確な遅延の生成である。
システムソフトウェアによるタイミングループにてセットする代わりに、設計者は自身の要求する希望量の初期カウント値を8253に設定する。
すると、設定した8253はカウント分の遅延後に自身のタスクが終了したCPUへ割り込みをかける。
ソフトウェアのオーバーヘッドを最小化し単純な構造に見えるようになり、優先度の割当により、複数の遅延を簡単にメンテナンスにすることができる。

その他、一般的なマイクロプロセッサに実装できる8253の機能。

- プログラム可能なレート・ジェネレータ
- イベントカウンタ
- バイナリ・レート・マルチプレクサ
- リアルタイムクロック
- ワンショット・パルス
- 複雑なモータ・コントローラ

![Figure1](img/8253A-Block.png)

Figure1 1. Block Diagram


![Figure2](img/8253A-Pin.png)

Figure1 2. Pin Configuration


### データバスバッファ

3ステート双方向8ビットバッファは、8253とシステムデータバスとをつなぐインターフェースとして使用する。
データはCPUの入出力命令の実行時時に送受信される。
データバスバッファは3つの基本的な機能を持つ。

1. プログラム可能な8253のモード
2. カウントレジスタへの書込み
2. カウント値の読取り


### 読取り/書込みロジック

読取り/書込みロジックはシステムバスとデバイス全体の操作のための制御信号からの入力を受け付ける。
CS信号によって有効/無効に設定されるため、システムロジックによって選択されていなければ、機能を変更するための操作は発生しない。

#### /RD (Read)
"LOW"入力によって8253に知らせると、CPUへカウント値のデータが入力される。

#### /WR (Write)
CPUがモード状態や書き込むカウント値を出力したことを、"LOW"入力によって8253に知らせる。

#### A0, A1
それらの入力は通常、アドレスバスに接続される。
それらの機能は、操作したい3つの内1つのカウンタを選択し、そのカウンタのモード選択のためのワードレジスタへのアドレスを指定することである。

#### /CS (Chip Select)
"LOW"入力によって8253へのアクセスが有効になる。デバイスが選択されなければ読み書きは発生しない。
/CSの入力はカウンタの動作に影響を与えない。


|/CS|/RD|/WR|A1|A0|                    |
|:--|---|---|--|--|--------------------|
|0  |1  |0  |0 |0 |Load Counter No.0   |
|0  |1  |0  |0 |1 |Load Counter No.1   |
|0  |1  |0  |1 |0 |Load Counter No.2   |
|0  |1  |0  |1 |1 |Write Mode Word     |
|0  |0  |1  |0 |0 |Read Counter No.0   |
|0  |0  |1  |0 |1 |Read Counter No.1   |
|0  |0  |1  |1 |0 |Read Counter No.2   |
|0  |0  |1  |1 |1 |No-Operation 3-State|
|1  |X  |X  |X |X |Disable 3-State     |
|0  |1  |1  |X |X |No-Operation 3-State|


### コントロール・ワード・レジスタ
コントロール・ワード・レジスタはA0,A1=11のときに選択される。
選択されるとデータバスバッファに情報が受け入れられ、レジスタへ格納される。
レジスタに格納する情報には、各カウンタの動作モード、BCDカウントモードの設定、そして各カウントレジスタのロード方法が含まれる。

コントロール・ワード・レジスタへは書込のみができる。読取り操作を行うことはできない。

### カウンタ #0, カウンタ #1, カウンタ #2
これら3つの機能ブロックの操作は同じため、1つのカウンタにとして説明をする。
1つのカウンタには単一で、16ビット長の、あらかじめ設定可能なダウンカウンタが含まれる。
カウンタは、バイナリまたはBCDの操作ができる。そしてコントロール・ワード・レジスタへロードしたモード選択設定による入力やゲート出力ができる。

3つのカウンタは完全に独立しており、それぞれに各カウンタの動作モード、カウント操作、BCDまたはバイナリを持つことができる。
また、それらのコントロール・ワードにある特別な機能はカウント値のロード処理をするためこれらの機能によってソフトウェアのオーバーヘッドを最小にすることができる。

各カウンタの内容の読み出しはイベントカウントアプリケーションの簡単な読み取り操作で利用可能である。特別なコマンドとロジックが8253に含まれているため、クロック入力を禁止することなく各カウンターの内容を"すぐに"読み取ることができる。

### 8253 システムインターフェース
8253はマイクロコンピュータシステムと他のすべてのファミリーの周辺機器と同じインターフェースのコンポーネントである。
システムソフトウェアによって配列された入出力ポート(3つのカウンタとモード設定のための4つの制御レジスタ)が扱われる。

基本的に、A0,A1入力はCPUのアドレスバスA0,A1に接続する。
/CSはをリニア・セレクト・メソッドを使用したアドレスバスより直接選択できる。
または、8205の大規模システムのようなデコーダ出力を接続することもできる。

![Figure4](img/8253A-System_Interface.png)

Figure1 4. 8253 System Interface


## 動作説明

### 概要
システムソフトウェアによって設定可能な8253のすべての機能について説明する。
8253の各カウンタのモード設定や情報をを初期化するには、コントロール・ワードへのセットをCPUから送信される必要がある。
初期化前は、すべてのカウンタのモード、カウント値、そして出力は未定義である。
それらのコントロール・ワードはモード、ローディング・シーケンス、そしてカウンタのバイナリ/BCD選択を設定する。

一度設定すると、8253は割り当てられたあらゆるタイミングのタスクを実行する準備ができる。

実際の各カウンタのカウント動作は、完全に独立しており、追加のロジックはオンチップで提供される。そのためマイクロコンピュータシステム外部の、非同期イベントやレートの効率的のモニタリングや管理といった通常の問題を解決する。

### 8253への設定
システムソフトウェアの単純なI/O操作によって各カウンタのすべてのモードが設定できる。

コントロール・ワード・レジスタへのコントロール・ワードの書込によって、8253の各カウンタは独立して設定できる。

#### コントロール・ワードの構成
|D7 |D6 |D5 |D4 |D3 |D2 |D1 |D0 |
|:--|---|---|---|---|---|---|---|
|SC1|SC0|RL1|RL0|M2 |M1 |M0 |BCD|

#### コントロール・ワードの定義
##### SC - 設定するカウンタの選択
|SC1|SC0|                |
|:--|---|----------------|
|0  |0  |Select Counter 0| |0  |1  |Select Counter 1| |1  |0  |Select Counter 2|
|1  |1  |Illegal         |

#### RL - 読取り/ロード方法
|RL1|RL0|                                                          |
|:--|---|----------------------------------------------------------|
|0  |0  |カウンターのラッチ操作(8253 読み書き手順を参照)           |
|0  |1  |最上位バイトの読取り/ロード                               |
|1  |0  |最下位バイトの読取り/ロード                               |
|1  |1  |最下位バイトの読取り/ロード後、最上位バイトの読取り/ロード|

#### M - モード
|M2|M1|M0|      |
|:-|--|--|------|
|0 |0 |0 |MODE 0|
|0 |0 |1 |MODE 1|
|X |1 |0 |MODE 2|
|X |1 |1 |MODE 3|
|1 |0 |0 |MODE 4|
|1 |0 |1 |MODE 5|

#### BCD
|BCD|                        |
|:--|------------------------|
|0  |16ビットバイナリカウント|
|1  |4つのBCDカウンタ        |

### カウンタのロード
カウントレジスタは、カウント値を書き込まれる(RLビットの選択に応じて1つか2つのバイト。)まではロードすることができず、その後に立ち上がりエッジと立ち下がりエッジが続く。
クロックの立ち下がりエッジ前にカウント値を読み取ると、無効なデータが生成されることがある。

### モードの定義
#### モード0: 最終カウントで割り込み
出力は、モード設定操作後LOW出力に初期化される。
選択したカウントレジスタのカウント値のロード後、出力はLOWを継続しカウンターはカウントを行う。
カウントが終了したとき、出力はHIGHとなりこの出力は選択されたカウントレジスタにモードがリロードされるか新しいカウント値がロードされるまで継続する。
カウント値は、カウントが終了するまでデクリメントをしていく。

カウント中にカウントレジスタを書き換えると、下記の結果となる。

1.  1回目のバイトの書込は、現在のカウントを停止させる。
2.  2回目のバイトの書込は、新しいカウントを開始させる。

#### モード1: ワンショットパルス
ゲート入力の立ち上がりエッジでカウントを開始し、出力はLOWになる。

カウントの終了で出力はHIGHになる。
出力がLOWの間の新しいカウント値のロードは、トリガが成功するまでワンショットパルスの動作時間に影響を与えない。
現在のカウント値は、ワンショットパルスの動作に影響を与えることなくいつでも読み出すことが出きる。

ワンショットパルスは再トリガすることが可能である。したがってゲートに立ち上がりエッジを入力することで、再度フルカウントと出力をLOWにすることができる。

#### モード2: レート・ジェネレータ
Nカウントの分割を行う。
入力クロックが1周期の間出力をLOWにする。
１つの出力パルスから次の出力パルスまでの期間は、カウントレジスタの入力カウント数に等しい。
現在の出力期間でのカウント値のリロードは、カウント動作に影響を与えない。しかし、次の期間には新しい値で動作するようなる。

ゲート入力がLOWのとき、出力は強制的にHIGHとなる。
ゲート入力をHIGHにしたとき、カウントは初期から始まる。
したがって、ゲート入力はカウンタの同期信号として使用できる。

このモードがセットされたとき、カウントレジスタがロードされるまでHIGH出力となる。
その後、ソフトウェアによって同期させることができる。

#### モード3: 方形波生成モード
モード2と似ていますが、半分の(偶数)カウントが完了するまでは出力HIGHを維持し、残りの半分のカウントでLOW出力となる。
これは、各クロックパルスの立ち下がりエッジでカウンタを2ずつデクリメントすることで実現される。
カウントが終了すると、出力状態を変更しカウントをリロードする。
全体のプロセスはこれを繰り返し行う。

もしもカウント値が奇数でHIGH出力の場合、最初のクロックパルス(カウントのロード後)は1つデクリメントする。
以降のクロックパルスでは2つデクリメントする。
タイムアウト後、出力がLOWとなりカウントがリロードされると、最初のクロックパルス(リロード後)は3つデクリメントされる。
以降のクロックパルスではタイムアウトするまで2つデクリメントされる。
全体のプロセスはこれを繰り返し行う。
この結果、カウントが奇数の場合、HIGH出力カウント数は(N + 1) / 2, LOW出力カウント数は(N - 1) / 2 となる。

モード2と3では、クロックソースにシステムソース以外を使用している場合、新しいカウント値の/WR信号の直後にGATEをパルスする必要がある。

#### モード4: ソフトウェア・トリガ・ストローブ
モード設定後、出力はHIGHとなる。
カウントをロードすると、カウンタはカウントを開始する。
カウント終了時、1つのクロック周期の間LOW出力をする。
その後、再度HIGH出力をする。

カウント中にカウントレジスタにリロードした場合、次のCLKパルスで新しいカウントにロードされる。
GATE入力がLOWの間、カウントは禁止される。

#### モード5: ハードウェア・トリガ・ストローブ
トリガー入力の立ち上がりエッジでカウンターのカウントを開始し、カウント終了時には、1つのクロック周期の間LOW出力をする。
カウンタは再トリガ可能である。
トリガーの立ち上がりエッジ後は、カウントが完了するまで出力LOWにならない。

|モード|Low、またはLOWに変化|立ち上がり|HIGH|
|:-----|--------------------|----------|----|
|0     |カウント無効|-|カウント有効|
|1     |-|1)カウント初期化<br>2)出力をリセットし次のクロックへ|-|
|2     |1)カウント無効<br>2)HIGHを即時出力|1)カウンタのリロード<br>2)カウントリセット|カウント有効|
|3     |1)カウント無効<br>2)HIGHを即時出力|1)カウンタのリロード<br>2)カウントリセット|カウント有効|
|4     |カウント無効|-|カウント有効|
|5     |-|カウント初期化|-|

Figure 6. Gate Pin Operations Summary

![Figure6](img/8253A-Timing.png)

Figure 7. 8253 Timing Diagrams


## 8253 読み書き手順
### 書込操作
システムソフトウェアは8253各カウンタのモードと必要な量のプログラムしなければならない。
プログラマは、実際にカウントを使用する前に8253へモード・コントロール・ワードとカウントレジスタバイト(1バイトまたは2バイト)へ書込を行わなければならない。

実際のプログラムの仕方はかなり柔軟である。
モード・コントロール・ワードへの書き出しはカウンタ選択のどの順番からでも行うことができる。
例えば、#0が最初のカウンタで、#2が最後のカウンタである必要はない。
各カウンタのモード・コントロール・ワード・レジスタはアドレス(SC0,SC1)によって分割されており、そのためそれらは完全に独立したシーケンスでロードしている。

ただし、カウントレジスタへの実際のカウント値のロードは、モード・コントロール・ワード(RL0, RL1)でプログラム可能なシーケンスで正確に実行する必要がある。
このカウンタのカウントレジスタのロードは、モード・コントロール・ワードのロードのようにシーケンスから独立している。
しかし、ロードされるカウントレジスタを選択したとき、モードコントロールレジスタ(RL0, RL1)に、そのレジスタにプログラムするバイト数をロードしなければならない。
1または2バイトのカウントレジスタへのロードは、関連するモード・コントロール・レジスタに続く必要はない。
正しいバイト数が順番にロードされてる限り、それらはモード・コントロール・ワードのロードに続いていつでもプログラムできる。

すべてのカウンタはダウンカウントである。そのため、カウントレジスタにロードされた値は、実際にはデクリメントされる。
カウントレジスタに0がロードされている場合、最大値でカウントする。(バイナリの場合は2^16、BCDの場合は10^4)
モード0では、ロードが完了するまでは新しいカウントを再開しない。
カウントはモード・コントロール・ワード(RL0,RL1)のプログラムに応じて、2のうち1つのバイトを受け入れる。
次に再起動操作に進む。

---
|   |MODE Control Word<br>Counter n    |
|:--|----------------------------------|
|LSB|Counter Register byte<br>Counter n|
|MSB|Counter Register byte<br>Counter n|

NOTE:

表示されているフォーマットは8253をロードする単純な例であり、唯一の使用できるフォーマットであることを意味するものではない。

---
Figure 8. Programming Format


---
|    |   |                                |A1|A0|
|:---|---|--------------------------------|--|--|
|No.1|   |MODE Control Word<br>Counter 0  |1 |1 |
|No.2|   |MODE Control Word<br>Counter 1  |1 |1 |
|No.3|   |MODE Control Word<br>Counter 2  |1 |1 |
|No.4|LSB|Count Register Byte<br>Counter 1|0 |1 |
|No.5|MSB|Count Register Byte<br>Counter 1|0 |1 |
|No.6|LSB|Count Register Byte<br>Counter 2|1 |0 |
|No.7|MSB|Count Register Byte<br>Counter 2|1 |0 |
|No.8|LSB|Count Register Byte<br>Counter 0|0 |0 |
|No.9|MSB|Count Register Byte<br>Counter 0|0 |0 |

NOTE:

各カウントレジスタの専用アドレスにより、8253へのプログラミングを非常に単純にし、機能がすべて初期化されている場合には、デバイスの効果を最大限に使用できる。

---
Figure 9. Alternate Programming Formats


### 読込操作
ほとんどのカウントアプリケーションでは進行しているカウント値の読取りが必要となりこの量をもとに計算・決定を行う。
イベントカウンタはこの機能を使用する最も一般的なアプリケーションとなる。
8253にはプログラマーが簡単に3つのどれかのカウンタから、実際に進行中のカウントを配布されることなく、カウント値を読み取ることができるロジックが含まれる。

プログラマーがカウンタの値を読み取るためには、2つの方法がある。
１つ目の方法は、選択したカウンタの単純なI/O読取り操作を呼び出すことである。
A0,A1を操作し8253へ入力することで、プログラマは選択したカウンタを読み出すことができる。(A0,A1='11'の場合の読取り操作はできないことを覚えておくこと)
この方法の唯一の要件は、選択したカウンターの実際の動作をゲート入力制御や外部回路によって禁止し、安定したカウントの読取りを保証することである。
選択したカウンターの内容は次のように利用できる:

- 1回目のI/O読取りには、最下位バイト(LSB)が含まれる。
- 2回目のI/O読取りには、最上位バイト(MSB)が含まれる。

8253の内部ロジックにより、読取り手順全体を完了させることが絶対に必要となる。
2バイトの読取りが必要な場合は、読み込み中のWRコマンドを同じカウンタに送信する前に読み取らなければならない。

#### 読取り操作チャート
|A1|A0|/RD|                 |
|:-|--|---|-----------------|
|0 |0 |0  |Read Counter No.0|
|0 |1 |0  |Read Counter No.1|
|1 |0 |0  |Read Counter No.2|
|1 |1 |0  |Illegal          |

### カウント中の読取り
カウント中の影響を無視してカウント値を読取りたいプログラマーのために8253は簡単なモードレジスタへの/WRコマンドアクセスを使用した特別なロジックを持つ。
基本的に、プログラマは"すぐに"選択したカウンタの内容を読み取れるように考えているとき、モードレジスタの特別なコードのロードをすることで、カウント値をストレージレジスタにラッチすることができる。
そのため、その内容には正確で安定した値が含まれている。
次に、プログラマーは通常の読取りコマンドを選択したカウンターに発行し、ラッチしたレジスターの内容が利用可能となる。

### モードレジスタのカウントラッチ
A0, A1=11
|D7 |D6 |D5|D4|D3|D2|D1|D0|
|:--|---|--|--|--|--|--|--|
|SC1|SC0|0 |0 |X |X |X |X |
SC1, SC0 - ラッチするカウンタの設定
D5, D4   - 00でカウンターのラッチを指示する
X        - don't care

前に設定した(読取り/ロード)方法と同じ制限が今回のカウンタ読取りにも適用される。
つまり、プログラムされたとおりに読取り操作を完了することは必須である。
このコマンドはカウントモードに影響を与えない。

![Figure10](img/8253A-Clock_Interface.png)

Figure 10. Clock Interface
