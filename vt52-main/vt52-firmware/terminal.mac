        .TITLE  TERM52 - VT52 TERMINAL
        .IDENT  /V04.00/

        .NLIST  ME
        .NLIST  MEX
        .NLIST	BEX
;==========================================================================================
; Терминал VT52/15ИЭ-00-013 - управляющая программа. 
;==========================================================================================
;
; Адреса устройств на общей шине
;
; 000000 - 017777 RAM с предзагруженной управляющей программой
; 140000 - 157777 - видеобуфер VGA
; 170000 - регистр адреса курсора
; 170002 - регистр управления терминалом
; 171000 - CSR клавиатуры PS/2
; 171002 - Регистр данных клавиатуры PS/2
; 177560 - CSR приемника UART
; 177562 - Регистр данных приемника UART
; 177564 - CSR передатчика UART
; 177566 - Регистр данных передатчика UART
;
;---------------------------------------------------------------------------
; Регистр управления терминалом VTCSR:
;
;   D0: 0 - локальная петля, 1 - связь с ЭВМ
;   D1: 0 - режим 24 строки, 1 - 38 строк
;   D2: 0 - курсор невидим, 1 - отображается
;   D3: форма курсора: 0 - подчеркивание, 1 - блок
;   D4: 1 - звуковой сигнал
;   D5: импульсы управления мерцанием знаков (0 - знак погашен, 1 - отображается)
;
;   D8..D10: скорость интерфейса:
;            000 - 1200
;            001 - 2400
;            010 - 4800
;            011 - 9600
;            100 - 19200
;            101 - 38400
;            110 - 57600
;            111 - 115200
;
; Адреса регистров устройств
;
TTINCSR = 177560  ; CSR приемника UART
TTINDAT = 177562  ; регистр данных приемника UART
TTOUTCSR = 177564 ; CSR передатчика UART
TTOUTDAT = 177566 ; регистр данных передатчика UART
KBCSR = 171000    ; регистр управления клавиатуры
KBDAT = 171002    ; регистр данных клавиатуры
CURPOS = 170000   ; регистр позиции курсора
VTCSR = 170002    ; регистр управления видеоконтроллером
VBUF = 140000     ; начало видеобуфера
RAMTOP = 020000   ; верхняя граница памяти

; биты регистра VTCSR

VC$ONL= 1       ; D0 - режим online/offline
VC$L38= 2       ; D1 - режим 24/38 строк
VC$VCUR=4       ; D2 - видимость курсора
VC$FCUR=10      ; D3 - форма курсора
VC$SND=20       ; D4 - звук
VC$FLASH=40     ; D5 - импульсы мерцания символов

; Длительность звукового сигнала в тактах системного таймера 50 Гц

LSOUND = 10.

; Параметры экрана

VBUFLIMIT=VBUF+6300       ; верхняя граница адресов видеопамяти
COLS=80.                  ; число столбцов
VBUFBOT=VBUF+<2*COLS>     ; нижняя граница пользовательского экрана (начало области выводимых данных)
VTOP40=VBUFBOT+<38.*COLS> ; верхняя граница пользовательского экрана в режиме 38 строк
VTOP24=VBUFBOT+<24.*COLS> ; верхняя граница пользовательского экрана в режиме 24 строк

; Служебная строка

RLINE=VBUF           ; адрес служебной строки - начало экрана
RL.MODE=RLINE        ; индикатор типа терминала
RL.ONL=RL.MODE+6.    ; индикатор ONLINE
RL.CAP=RL.ONL+10.	 ; индикатор CAPS
RL.ALT=RL.CAP+6.     ; индикатор ALT
RL.L38=RL.ALT+6.     ; индикатор L38
RL.KOI=RL.L38+6.     ; индикатор KOI7
RL.HLD=RL.KOI+6.     ; индикатор HOLD
RL.SCR=RL.HLD+6.     ; индикатор WAIT
RL.MUT=RL.SCR+6.     ; индикатор MUTE

RL.SPD=RLINE+62.     ; текущая скорость интерфейса
RL.TIM=RLINE+71.     ; время работы терминала
;
; Коды управляющих символов
;
HT       = 11		; табуляция
LF       = 12		; перевод строки
CR       = 15		; курсор в начало строки
ESC      = 33
BS       = 10
DEL      = 177

; Префиксные сканкоды клавиатуры

P$KBEX  = 340   ; расширенные сканкоды E0
P$KBOFF = 360   ; отпускаение кнопок F0

;===========================================================================
;   Раскладка кодов символов в шрифтовом файле
;  hex     oct
; 00-1f  000-037  большие латинские буквы (для индикации управляющих кодов)
; 20-3f  040-077  цифры и обычные символы
; 40-5f  100-137  большие латинские буквы
; 60-7f  140-177  малые латинские буквы
; 80-9f  200-237  псевдографика
; a0-bf  240-277  не используется
; c0-df  300-337  малые русские буквы
; e0-ff  340-377  большие русские буквы

;*************************************************
; Макрос для генерации векторов прерываний
;*************************************************
		.MACRO	IV, ADR
		.IF 	NB, <ADR>				
		.WORD	ADR			; Если адрес обработчика указан, вписываем его
		.IFF						
		.WORD	START		; Если нет, то указываем START - полный перезапуск прошивки
		.ENDC 						
		.WORD	340			; PS=340 всегда
		.ENDM				

	  .ASECT

;*************************************************
; Таблица векторов прерываний
;*************************************************
	  IV 	START 	; 0   Вектор начального пуска
	  IV			; 4 	
	  IV			; 10	
	  IV			; 14	
	  IV			; 20	
	  IV			; 24	
	  IV			; 30	
	  IV			; 34	
	  IV			; 40	
	  IV			; 44	
	  IV			; 50	
	  IV	KBRIRQ	; 54  Клавиатура PS/2
	  IV	RXIRQ	; 60  Приемник UART
	  IV	TXIRQ	; 64  Передатчик UART
	  IV			; 70	
	  IV			; 74	
	  IV	TMRIRQ  ; 100 Интервальный таймер 50 Гц			
	  
;**************************************************
;* Стартовая точка входа
;**************************************************
START:
         MOV 	#RAMTOP,SP		          ; стек - на верху области памяти
;
; Настройка указателей кольцевых буферов
;
         CLR 	DBUFSTORE                 ; буфер данных UART 
         CLR 	DBUFLOAD                   
         CLR 	KBUFSTORE                 ; буфер данных клавиатуры 
         CLR 	KBUFLOAD   
         
; настройка флаговых регистров        
         CLR	ESCFLAG
         MOV    #KB$CAPS,KBFLAG    ; включаем Caps Lock
         MOV 	#ST$ONL,SYSFLAG    ; поднимаем флаг Online
;
; установка режима 24 строки
;
         MOV    #VTOP24,VBUFTOP     ; текущая верхняя граница видеобуфера
;
; Подготовка экранного буфера
;
         CALL	CLSCREEN	    ; чистим экран
;
; Чтение начальной скорости интерфейса
;
         MOV    @#VTCSR,R1
         SWAB   R1           ; переносим скорость в младший байт
         BIC    #177770,R1   ; выделяем биты 0..3 - индекс скорости
         MOV    R1,SPEED     ; сохраняем индекс скорости
;
; Включение курсора
;
         BIS    #VC$VCUR,@#VTCSR
;
; Запуск таймера задержки приема с клавиатуры
; Он нужен, чтобы пропустить переходный мусор, идущий с клавиатуры при включении  
; 
         MOV    #30.,KBTIMER  ; запускаем на 0.5с. 
;
; Подготовка таймера мерцания символов
;
         MOV    #10.,FLTIMER
;
; Настройка разрешения прерываний
;
          MOV 	#100,@#TTINCSR         ; открываем прерывания от приемника уарта
          MOV 	#100,@#KBCSR	       ; и от клавиатуры
          MTPS  #0                     ; разрешаем прерывания процессора
;          
; выводим строку состояния
;
          CALL 	RLSHOW 		
         
;***********************************************
;*   Основной цикл обработки данных. 
;***********************************************

MLOOP:
         MOV    SYSFLAG,R5
         ADD    KBFLAG,R5   ; формируем хеш флагов
         CALL 	KBIN		; Обрабатываем данные с клавиатуры
         BCS	10$ 		; есть данные от клавиатуры - обрабатываем их всех, вывод на экран приостанавливаем
         CALL	TTOUT 		; Обрабатываем выводимые на экран данные
10$:         
         MOV    SYSFLAG,R0
         ADD    KBFLAG,R0   ; новый хеш флагов
         CMP    R0,R5       ; флаги поменялись?
         BEQ    MLOOP       ; нет
         CALL 	RLSHOW 		; обновляем строку состояния
         BR	    MLOOP

;********************************************
;* Обработка выводимых на экран данных
;********************************************
TTOUT:	 
; проверка на hold screen
         BIT    #ST$WAIT,SYSFLAG     ; установлен признак задержки вывода?
         BEQ    10$                 ; нет - продолжаем вывод
         BIT    #KB$SCR,KBFLAG      ; нажат scoll lock?
         BEQ    TTEMPTY             ; нет - вывод на экран не производим
; scroll нажат
         BIT 	#<KB$LSHIFT!KB$RSHIFT>,KBFLAG   ; SHIFT нажат?
         BEQ    5$                  ; нет
         MOV    #23.,SDELAY         ; нажат shift+scroll - откладываем задржку на 24 строки
5$:         
         BIC    #KB$SCR,KBFLAG      ; scroll нажат - снимаем его флаг
         BIC    #ST$WAIT,SYSFLAG     ; и флаг задержки - вывод разрешен
         MOV    #21,R0              ; отсылаем XON (ctrl-q)
         CALL   UTTOUT
10$:
         CALL 	 DBLOAD		; принимаем байт из уарта
         BCC 	 TTEMPTY    ; данных пока не поступало
         MOVB 	 R1,R0      ; принятый байт
         BIC 	 #177600,R0 ; Сбрасываем старший бит - у нас 7-битный терминал
         CALL 	 CHCONTROL	; Обрабатываем управляющие коды
         TST 	 R0         ; обработчик вернул 0?
         BEQ 	 99$		; управляющий код обработан и в видеобуфер не записывается
;
; Обработка неподдерживаемых управляющих символов в диапазоне 00-37
;
         CMP     R0,#40
         BGE     15$        ; код больше 3F - обрабатываем далее
         BR      30$        ; код до 3F просто выводим в экранный буфер
;
; Обработка режима псевдографики
;
15$:
        BIT     #ST$GRF,SYSFLAG
        BEQ     20$         ; режим отключен
        CMP     R0,#137     ; попадаем в область псевдографических символов 137-177? 142->203
        BLT     20$         ; нет
        ADD     #41,R0      ; коррекция кода символа - переводим в область 200-237
        BR      30$
;
; Обрабатываем режим koi-7
;
20$:
         BIT 	 #KB$KOI7,KBFLAG
         BEQ 	 50$        ; режим KOI7 не включен
         CMP 	 R0,#140    ; коды до 140 общие в обоих режимах
         BLT 	 30$
25$:         
         ADD 	 #200,R0     ; преобразуем код ASCII в KOI7: 140-177 -> 340-377
         BR      30$
;
; Обработка режимов rus-lat
;
50$:
        BIT      #KB$LANG,KBFLAG
        BEQ      30$        ; режим LAT - все коды уже на месте
        CMP 	 R0,#77     ; коды до 77 общие в обоих режимах
        BGE 	 25$        ; остальные коды переносим в русскую часть шрифта: 100-177 -> 300-377
;
; Обработка отображаемых символов
;
30$:
         MOV 	 TCUR,R3    ; адрес курсора
         MOVB 	 R0,(R3)	; записываем байт в видеобуфер по текщему положению курсора
         MOV 	 R3,R2
         CALL 	 CLADDR     ; адрес начала текущей строки -> R3
         ADD 	 #<COLS-1>,R3 ; получаем адрес последнего знака текущей строки
         CMP 	 R2,R3      ; это текущая позиция? 
         BEQ 	 99$        ; да - сдвигаться некуда
         INC 	 R2         ; сдвигаем позицию курсора вперед
         MOV 	 R2,TCUR
99$:
         MOV 	 TCUR,@#CURPOS	; устанавливаем аппаратный курсор в текущую позицию
TTEMPTY:
         RETURN 

;************************************
;*  Обработка спецсимволов
;************************************
CHCONTROL:
        BIT 	#ESC$ON,ESCFLAG ; проверяем на активную esc-последовательность
        BEQ	    4$
        CALL	ESCPROCESS      ; обрабатываем esc-последовательность
        BR	    CHCDONE

;-----------------------------------------         
;  Команды, общие для обоих режимов
;-----------------------------------------         
4$:         
        CMPB 	R0,#CR          ; 15 - CR
        BNE 	6$
        CALL	BLINE
        BR 	    CHCDONE
;----------------------------         
6$:         
        CMPB 	R0,#LF          ; 12 - LF
        BNE     12$
        CALL    LFEED
        BR 	    CHCDONE
;---------------------------- 
12$:
        CMPB 	R0,#17          ; 17 - LAT
        BNE     15$
        BIC 	#KB$LANG,KBFLAG
        BR 	    CHCDONE
;---------------------------- 
15$:
        CMPB 	R0,#16          ; 16 - RUS
        BNE     16$
        BIS 	#KB$LANG,KBFLAG
        BR 	    CHCDONE
;---------------------------- 
16$:
        CMPB 	R0,#07          ; 07 - звуковой сигнал
        BNE     80$
        BIT     #ST$MUT,SYSFLAG ; звук разрешен?
        BNE     CHCDONE          ; нет
        MOV 	#LSOUND,STIMER   ; взводим таймер
        BIS     #VC$SND,@#VTCSR  ; включаем звук
        BR 	    CHCDONE
;---------------------------- 
80$:
        CMPB    R0,#177          ; 177 - DEL - игнорируем
        BEQ	    CHCDONE
;---------------------------------
        BIT     #ST$MODE,SYSFLAG ; проверяем текущую систему команд
        BNE     CH15IE           ; режим 15ИЭ
                
;-------------------------------------------- 
; Команды, специфичные для режима VT52
;--------------------------------------------
        CMPB    R0,#10          ; 10 - BS
        BNE     210$
        CALL    CLEFT
        BR      CHCDONE
;----------------------------
210$:
        CMPB 	R0,#HT          ; 11 - HT, горизонтальная табуляция
        BNE     220$
        CALL    HTAB
        BR 	    CHCDONE
;----------------------------
220$:
        CMPB 	R0,#13          ; 13 - аналог LF
        BNE     230$
        CALL    LFEED
        BR 	    CHCDONE
;----------------------------
230$:
        CMPB 	R0,#14          ; 14 - аналог LF
        BNE     250$
        CALL    LFEED
        BR 	    CHCDONE
;----------------------------
250$:
        CMPB 	R0,#5           ; 5 - идентификация
        BNE     102$
        CALL    IDENTIFY
        BR 	    CHCDONE
;----------------------------
102$:
        CMPB	R0,#ESC		; ESC - начало esc-последовательности
        BNE	    CHPASS
        BIS	    #ESC$ON,ESCFLAG ; устанавливаем флаг начала последовательности
;----------------------------         
CHCDONE:
        CLR 	R0		 ; R0==0 - признак обработанного спецсимвола
CHPASS:
        RETURN

;-------------------------------------------- 
; Команды, специфичные для режима 15ИЭ
;--------------------------------------------
CH15IE:        
        CMPB    R0,#10        ; возврат - курсор в начало экрана
        BNE     10$
        CALL    HOME
        BR      CHCDONE
;----------------------------         
10$:
        CMPB    R0,#13        ; стирание строки
        BNE     20$
        CALL    CLREOL
        BR      CHCDONE
;----------------------------         
20$:        
        CMPB    R0,#14        ; сброс - очитска экрана
        BNE     30$
        CALL    CLSCREEN
        BR      CHCDONE
;----------------------------         
30$:
        CMPB    R0,#22        ; сдвиг текста вверх
        BNE     40$
        CALL    SCRLUP
        BR      CHCDONE
;----------------------------         
40$:
        CMPB    R0,#23        ; размыкание - сдвиг текста вправо
        BNE     50$
        CALL    INSBLANK
        BR      CHCDONE
;----------------------------         
50$:
        CMPB    R0,#24        ; смыкание - сдвиг текста влево
        BNE     60$
        CALL    DELCHAR
        BR      CHCDONE
;----------------------------         
60$:
        CMPB    R0,#25        ; курсор в начало следующей строки
        BNE     70$
        CALL    BLINE         ; переходим в начало текущей строки
        ADD     R3,#80.       ; добавляем размер строки
        CMP     R3,VBUFTOP    ; не выщли ли мы за границу видеобуфера?
        BGE     65$           ; вышли - игнорируем команду
        MOV     R3,TCUR       ; устанавливаем новую позицию курсора
65$:
        BR      CHCDONE
;----------------------------         
70$:
        CMPB    R0,#26        ; сдвиг текста вниз
        BNE     80$
        CALL    SCRLUP
        BR      CHCDONE
;----------------------------         
80$:
        CMPB    R0,#27        ; переход в режим VT52
        BNE     90$
        BIC     #ST$MODE,SYSFLAG
        BR      CHCDONE
;----------------------------         
90$:
        CMPB    R0,#31        ; курсор вправо
        BNE     100$
        CALL    CRIGHT
        BR      CHCDONE
;----------------------------         
100$:
        CMPB    R0,#32        ; курсор влево
        BNE     110$
        CALL    CLEFT
        BR      CHCDONE
;----------------------------         
110$:
        CMPB    R0,#34        ; курсор вверх
        BNE     120$
        CALL    CUP
        BR      CHCDONE
;----------------------------         
120$:
        CMPB    R0,#35        ; курсор вниз
        BNE     130$
        CALL    CDOWN
        BR      CHCDONE
;----------------------------         
130$:
        BR      CHPASS
        
;****************************************
;* Обработка ESC-последовательностей
;****************************************
ESCPROCESS:
;
;  Обработка байтов команды ESC-Y - прямое позиционирование курсора
;
        BIT 	#ESC$Y1,ESCFLAG ; идет прием второго байта ESC-Y?
        BEQ	    3$              ; нет
        SUB	    #40,R0
        MOV	    R0,ESCY1C       ; сохраняем второй байт-40
        CALL 	CURMOVE         ; производим прямое позиционирование курсора
        BIC 	#ESC$Y1,ESCFLAG ; снимаем флаг Y1
        JMP	    98$
3$:
        BIT 	#ESC$Y0,ESCFLAG ; идет прием первого байта ESC-Y?
        BEQ	    4$              ; нет
        SUB	    #40,R0
        MOV     R0,ESCY0L       ; сохраняем первый байт-40
        BIC 	#ESC$Y0,ESCFLAG ; снимаем флаг приема первого байта
        BIS	    #ESC$Y1,ESCFLAG ; поднимаем флаг приема второго байта
        RETURN
;
; Обработка однобайтовых ESC-команд
;
4$:
        CMPB	R0,#'B 		; cursor down   
        BNE	    5$
        CALL 	CDOWN
        BR	    98$
5$:
        CMPB	R0,#'A 		; cursor up
        BNE	    6$
        CALL 	CUP
        BR	    98$
6$:	
        CMPB	R0,#'C 		; cursor right
        BNE	    7$
        CALL 	CRIGHT
        BR	    98$
7$:	
        CMPB	R0,#'D 		; cursor LEFT
        BNE	    8$
        CALL 	CLEFT
        BR	    98$
8$:	
        CMPB	R0,#'H 		; cursor HOME
        BNE	    9$
        CALL 	HOME
        BR	    98$
9$:	
        CMPB	R0,#'Y          ; прямое позиционирование курсора
        BNE	    10$
        BIS	    #ESC$Y0,ESCFLAG
        RETURN
10$:	
        CMPB	R0,#'J 		; стирание до конца экрана
        BNE	    11$
        CALL 	CLREOS
        BR	    98$
11$:
        CMPB	R0,#75 		; ALTMODE ON
        BNE	    30$
        BIS 	#KB$ALT,KBFLAG
        BR 	    98$
30$:
        CMPB 	R0,#76		; ALTMODE OFF
        BNE	    40$
        BIC 	#KB$ALT,KBFLAG
        BR 	    98$
40$:
        CMPB	R0,#'K 		; стирание до конца строки
        BNE	    20$
        CALL 	CLREOL
        BR	    98$
20$:	
        CMPB	R0,#111 	; обратный LF
        BNE	    33$
        CALL 	REVLF
        BR	    98$
33$:
        CMPB 	R0,#'Z		; идентификация моделей
        BNE	    60$
        CALL 	IDENTIFY
        BR	    98$
60$:
        CMPB 	R0,#'E		; переход к системе команд 15ИЭ
        BNE	    38$
        BIS     #ST$MODE,SYSFLAG
        BIC     #<ST$HLD!ST$WAIT>,SYSFLAG  ; снимаем режим hold screen
        BIC 	#KB$ALT,KBFLAG             ; отключаем альтернативную клавиатуру
        BR      98$
38$:
        CMPB 	R0,#'F		; вход в псевдографический режим
        BNE	    45$
        BIS     #ST$GRF,SYSFLAG
        BR	    98$
45$:
        CMPB 	R0,#'G		; выход из псевдографического режима
        BNE	    50$
        BIC     #ST$GRF,SYSFLAG
        BR	    98$
50$:
        CMPB 	R0,#133		; включение hold screen
        BNE	    55$
        BIS     #ST$HLD,SYSFLAG
        MOV     #23.,SDELAY    ; устанавливаем отсрочку задержки экрана на 24 строки
        BR	    98$
55$:
        CMPB 	R0,#134		; выключение hold screen
        BNE	    98$
        BIC     #KB$SCR,KBFLAG
        BIC     #<ST$HLD!ST$WAIT>,SYSFLAG
        MOV     #23.,SDELAY    ; предотвращаем дальнейшие задержки экрана
        BR	    98$
98$:	
        BIC 	#ESC$ON,ESCFLAG  ; снимаем флаг активной ESC-последовательности
        RETURN

;*****************************************
;* Копирование текстовых строк
;*   R0 - src
;*   R1 - dst
;*****************************************
STRCPY:
        MOVB   (R0)+,(R1)+
        TSTB   (R0)
        BNE    STRCPY
        RETURN
        
;**************************************
;* Вывод индикаторов служебной строки
;**************************************
RLSHOW:
        BIT     #ST$MODE,SYSFLAG  ; система команд - VT52 или 15ИЭ
        BNE     100$
        MOV     #RLI$VT52,R0
        BR      150$
100$:   MOV     #RLI$15,R0
150$:   MOV     #RL.MODE,R1        
        CALL    STRCPY

        BIT 	#KB$CAPS,KBFLAG   ;caps
        BEQ 	10$
        MOV 	#RLI$CAP,R0
        BR 	    15$
10$: 	MOV 	#RLI$BLK,R0
15$:    MOV 	#RL.CAP,R1
        CALL 	STRCPY
        
        BIT 	#KB$ALT,KBFLAG    ;alt
        BEQ 	20$
        MOV 	#RLI$ALT,R0
        BR 	    25$
20$: 	MOV 	#RLI$BLK,R0
25$:    MOV 	#RL.ALT,R1
        CALL 	STRCPY
        
        BIT 	#ST$L38,SYSFLAG  ; L38/L24
        BEQ	    30$
        MOV 	#RLI$L38,R0
        BR 	    35$
30$:	MOV 	#RLI$L24,R0
35$:	MOV 	#RL.L38,R1
        CALL 	STRCPY

        BIT 	#KB$KOI7,KBFLAG  ; KOI7/Rus-Lat
        BEQ	    40$
        
; Режим KOI-7

        MOV 	#RLI$KOI,R0
        BR 	    45$
40$:
; Режим  RUS-LAT
    
        BIT     #KB$LANG,KBFLAG
        BEQ     41$
        MOV 	#RLI$RUS,R0
        BR      45$
41$:        
        MOV 	#RLI$LAT,R0
45$:
        MOV 	#RL.KOI,R1
        CALL 	STRCPY
	
        BIT 	#ST$ONL,SYSFLAG  ; LINE/LOCAL
        BEQ	    50$
        MOV 	#RLI$ONL,R0
        BR 	    55$
50$:	MOV 	#RLI$LOC,R0
55$:	MOV 	#RL.ONL,R1
        CALL 	STRCPY

        BIT 	#ST$HLD,SYSFLAG  ; HOLD
        BEQ	    60$
        MOV 	#RLI$HLD,R0
        BR 	    65$
60$:	MOV 	#RLI$BLK,R0
65$:	MOV 	#RL.HLD,R1
        CALL 	STRCPY

        BIT 	#ST$WAIT,SYSFLAG  ; WAIT
        BEQ	    70$
        MOV 	#RLI$SCR,R0
        BR 	    75$
70$:	MOV 	#RLI$BLK,R0
75$:	MOV 	#RL.SCR,R1
        CALL 	STRCPY

        BIT 	#ST$MUT,SYSFLAG  ; MUTE
        BEQ	    80$
        MOV 	#RLI$MUT,R0
        BR 	    85$
80$:	MOV 	#RLI$BLK,R0
85$:	MOV 	#RL.MUT,R1
        CALL 	STRCPY
        
; вывод текущей скорости интерфейса
        MOV     SPEED,R1     ; текущая скорость
        MUL     #6,R1        ; умножаем на длину строки скорости
        ADD     #RSPEED,R1   ; получаем смещение к нужной строке скорости
        MOV     #RL.SPD,R0
        MOV     (R1)+,(R0)+  ; копируем в строку состояния
        MOV     (R1)+,(R0)+
        MOV     (R1)+,(R0)+
        RETURN
	
;****************************************
;* Идентификация моделей терминала
;****************************************
IDENTIFY:
        MOV 	#ESC,R0		; последовательность - ESC / L
        CALL 	UTTOUT		; в буфер
        MOV 	#'/,R0
        CALL 	UTTOUT
        MOV 	#'L,R0
        CALL 	UTTOUT
        RETURN

;***********************************************************
;*  Вставка пробела в позицию курсора (размыкание строки)
;***********************************************************
INSBLANK:
        CALL    CLADDR         ; адрес начала строки -> R3
        ADD     #80.,R3        ; адрес начала следующей строки
        MOV     TCUR,R0        ; текущий адрес курсора
        MOV     R3,R2
        DEC     R2             ; адрес последнего байта текущей строки
10$:
        MOVB    -(R2),-(R3)    ; сдвигаем вперед хвост строки от курсора до конца строки,
                               ; начиная от конца строки 
        CMP     R2,R0          ; доехали до позиции курсора? 
        BNE     10$            ; нет
        MOVB    #' ,(R0)       ; вставляем пробел в точку разрыва 
        RETURN

;***********************************************************
;*  Удаление символа в позиции курсора (смыкание строки)
;***********************************************************
DELCHAR:
        CALL    CLADDR         ; адрес начала строки -> R3
        ADD     #80.,R3        ; адрес начала следующей строки
        MOV     TCUR,R0        ; текущий адрес курсора
        MOV     R0,R2
        INC     R2             ; адрес байта, следующего за курсором
10$:
        MOVB    (R2)+,(R0)+    ; сдвигаем все байты назад от курсора до конца строки
        CMP     R2,R3          ; конец строки?
        BNE     10$            ; нет
        MOVB    #' ,(R3)       ; вставляем пробел в последний байт строки
        RETURN

        
;****************************************
;*  Очистка от курсора до конца экрана
;****************************************
CLREOS:
        MOV 	TCUR,R3
10$:
        MOVB	#40,(R3)+      ; заполняем буфер проблеами
        CMP 	R3,#VTOP40     ; до верхней границы
        BNE	    10$
        RETURN

;****************************************
;*  Очистка от курсора до конца строки
;****************************************
CLREOL:
        MOV 	TCUR,R4  
        CALL 	CLADDR   	; адрес начала строки
        ADD 	#COLS,R3		; адрес последнего байта строки
10$:
        MOVB	#40,(R4)+       ; вписываем пробелы
        CMP 	R4,R3           ; до конца строки
        BNE	    10$
        RETURN
	
;**************************************
;* Прямое позиционирование курсора
;**************************************
CURMOVE:
        MOV	    ESCY0L,R1     ; байт 1 - номер строки
; проверяем, не вышел ли номер строки за пределы экрана        
        CMP 	R1,#24.
        BLT 	4$
; номер строки выходит за пределы экрана - не делаем горизонтальное перемещение
        CALL    CLADDR        ; адрес начала строки -> R3
        SUB     #VBUFBOT,R3   ; получаем смещение от начала экрана до начала строки
        MOV     R3,R1
        BR      10$
4$:
        MUL     #COLS,R1      ; умножаем на длину строки	
10$:
        MOV 	ESCY1C,R0     ; байт 2 - номер позиции
        CMP 	R0,#COLS      ; проверяем его
        BLT 	20$           
        MOV     #COLS,R0      ; позиция превышает длину строки - встаем на правую границу строки
20$:
        ADD 	R0,R1         ; добавляем к адресу начала строки
        ADD 	#VBUFBOT,R1   ; + начальный адрес экрана
        MOV     VBUFTOP,R0    ; верхняя граница
        CMP 	R1,R0
        BGE	    50$           ; выход за границу видеобуфера
        MOV 	R1,TCUR
50$:	RETURN	
	
;*************************
;* BS - курсор назад
;*************************
CLEFT:
        CALL 	CLADDR		; ->R3
        CMP 	TCUR,R3     ; курсор стоит в начале строки?
        BEQ	    10$         ; да - игнорируем команду
        DEC     TCUR		; сдвигаем курсор на символ назад
10$:	RETURN

         
;******************************
;* скролл экрана вверх
;******************************
SCRLUP:
        BIT     #ST$HLD,SYSFLAG  ; режим HOLD Screen ?
        BEQ     100$            ; HOLD выключен
        TST     SDELAY          ; счетчик задержки 
        BEQ     50$             ; задержки нет
        DEC     SDELAY          ; уменьшаем счетчик 
        BR      100$            ; и продолжаем обработку скролла
50$:        
        BIS     #ST$WAIT,SYSFLAG ; поднимаем признак задержки экрана
        MOV     #23,R0          ; отправляем Xoff (ctrl/s)
        CALL    UTTOUT

100$:           
        MOV     #VBUFBOT+COLS,R1	; R1 = адрес начала строки 1
        MOV     #VBUFBOT,R2	; R2 = адрес начала строки 0	
        MOV     VBUFTOP,R4	; R4 = адрес конца последней строки
102$:
        MOV     (R1)+,(R2)+	; перемещаем весь видеобуфер на строку назад
        CMP     R1,R4
        BNE     102$
101$:           
        MOV     #20040,(R2)+	; очищаем последнюю строку
        CMP     R2,R4
        BNE     101$
        RETURN

;******************************
;* скролл экрана вниз
;******************************
SCRLDWN:
        MOV     VBUFTOP,R1    ; верхняя граница видеобуфера
        MOV     R1,R2
        SUB     #COLS,R2      ; адрес начала последней строки экрана
100$:           
        MOV     -(R2),-(R1)	; перемещаем весь видеобуфер на строку назад
        CMP     R2,#<VBUFBOT> ; доехали до начала буфера?
        BNE     100$          ; нет 
	    MOV 	#VBUFBOT,R2   ; начало видеобуфера
101$:           
        MOV     #20040,(R2)+	; очищаем первую строку
        CMP     R2,#<VBUFBOT+COLS>
        BNE     101$
        RETURN

;*****************************************
; Reverse LF - строка вверх со скроллом
;*****************************************
REVLF:
        CMP 	TCUR,#VBUFBOT+COLS ; мы стоим на первой строке?
        BLT 	10$                ; да - скролл вниз
        SUB 	#COLS,TCUR         ; иначе просто сдвигаем курсор на строку вверх
        RETURN
10$:
        CALL 	SCRLDWN
        RETURN
	 
;*************************************
;* LF - строка вниз (со скроллом)
;*************************************
LFEED:
        MOV     TCUR,R3
        MOV     VBUFTOP,R0
        SUB     #COLS,R0
        CMP 	R3,R0               ; доехали до границы буфера?
        BLT 	10$                 ; нет - просто сдвигаем курсор вниз
30$:	 
        CALL	SCRLUP              ; скролл вверх
        RETURN
10$:
        ADD    #COLS,R3 	; Добавляем длину строки к номеру строки
        MOV 	R3,TCUR
        RETURN
         
;*******************************
;* Курсор вниз (без скролла)
;*******************************
CDOWN:
        MOV 	TCUR,R3
        MOV     VBUFTOP,R0    ; верхняя граница видеобуфера
        SUB     #COLS,R0      ; адрес начала последней строки
        CMP 	R3,R0         ; курсор стоит на последней строке?
        BGE	    10$           ; да - игнорируем команду
        ADD 	#COLS,R3      ; сдвигаем курсор на строку вниз
        MOV 	R3,TCUR
10$:	RETURN	

;*******************************
;* Курсор вверх (без скролла)
;*******************************
CUP:
        MOV 	TCUR,R3            
        CMP 	R3,#VBUFBOT+COLS  ; курсор стоит на первой строке?
        BLT	    10$               ; да - игнорируем команду
        SUB 	#COLS,R3          ; иначе сдвигаем курсор вверх на строку
        MOV 	R3,TCUR
10$:	RETURN	

;*******************************
;* Курсор вправо
;*******************************
CRIGHT:
        CALL   CLADDR
        ADD	   #79.,R3
        CMP    TCUR,R3   ; курсор стоит на последнем байте строки?
        BEQ    10$		 ; да - команда игнорируется
        INC    TCUR		 ; сдвигаем курсор на символ вперед
10$:	RETURN


;**************************************************         
;* Получение адреса начала текущей строки -> R3
;**************************************************         
CLADDR:
         MOV    TCUR,R1        ; текущий адрес курсора
         SUB    #VBUFBOT,R1    ; смещение от начала видеобуфера до курсора
         CLR    R0             
         DIV    #COLS,R0       ; делим на число столбцов
         MOV    R0,R3          ; результат деления (остаток отбрасываем)
         MUL    #COLS,R3       ; умножаем на число столбцов - получаем смещение до первого столбца строки
         ADD    #VBUFBOT,R3    ; добавляем адрес начала видеобуфера
         RETURN

;**********************************         
;* CR - курсор в начало строки         
;**********************************
BLINE:
        CALL	CLADDR          ; адрес начала строки -> R3
        MOV 	R3,TCUR         
        RETURN

;***************************
;* Очистка видеобуфера
;***************************
CLSCREEN:
        MOV     #VBUF,R0
1$:
        MOV     #20040,(R0)+              ; Заполняем видеобуфер пробелами
        CMP     R0,#VBUFLIMIT         ; верхняя физическая граница видеобуфера
        BNE     1$
; вывод разделительной строки
        MOV     #<VBUF+COLS>,R0       ; вторая физическая строка экрана
        MOV     #<40.>,R1             ; длина строки/2
5$:     MOV     #106615,(R0)+         ; код 215 (8D) - горизонтальная черта
        SOB     R1,5$

;************************************
;*  Курсор - в верхний левый угол
;************************************
HOME:
         MOV 	#VBUFBOT,R3	   ; начало видеобуфера
         MOV	R3,TCUR
         MOV 	R3,@#CURPOS	; устанавливаем аппаратный курсор в текущую позицию
         RETURN

;************************************
;* Горизонтальная табуляция
;************************************
HTAB:
        CALL 	CLADDR      ; адрес начала строки ->R3
        ADD	    #79.,R3	    ; адрес последнего байта строки
        CMP 	TCUR,R3     ; если кусор стоит на нем - ничего не делаем
        BNE	    10$
        RETURN
10$:	
        SUB 	#7,R3       ; адрес байта 72 текущей строки
        CMP 	TCUR,R3     ; курсор стоит в позиции 72 или выше?
        BLT 	30$	    ; нет
        INC 	TCUR        ; для позиций 72-78 просто сдвигаем курсор вперед
        RETURN
30$:	
        BIS	    #7,TCUR     ; Выходим на следующую полизию кратную 8
        INC 	TCUR
        RETURN
             
;**************************************************************
;* Загрузка байта из буфера входящих (дисплейных) данных
;**************************************************************
DBLOAD:
;        MTPS   #200                      ; Запрещаем все прерывания
         MOV    DBUFLOAD,R0               ; указатель чтения буфера
         MOV    DBUFSTORE,R1              ; указатель хвоста буфера
         CMP    R0,R1                     ; совпадают?
         BNE    10$                       ; нет
         MTPS   #0                        ; открываем прерывания, C=0
         RETURN
;
; Буфер не пуст
;
10$:
         INC    R0                        ; Продвигаем указатель
         BIC 	#177600,R0		          ; заворот на границу буфера
         MOV    R0,DBUFLOAD               ; сохраняем указатель
         ADD    #DBUF,R0                  ; добавляем адрес начала буфера
         MOVB   (R0),R1                   ; загружаем текущий байт из буфера
         MTPS   #1                        ; открываем прерывания, C=1
         RETURN


;=======================================
;========    Модуль клавиатуры ===============================================================================                
;=======================================

;****************************************************************
;* Загрузка данных из буфера клавиатуры 
;*   R1 - выходной байт
;*   R0=0 - буфер пуст, R1=1 - принят байт
;****************************************************************
KBLOAD:
         MTPS  #200                       ; Запрещаем все прерывания
         MOV   KBUFLOAD,R0               ; 
         MOV   KBUFSTORE,R1              ; указатель чтения буфера
         CMP   R0,R1                     ; указатель хвоста буфера
         BNE   10$                       ; совпадают?
         CLR   R0                        ; Нет
         BR    90$                       
10$:          
         INC   R0                        ; Продвигаем указатель
         BIC   #177700,R0
         MOV   R0,KBUFLOAD             ; сохраняем указатель
         ADD   #KBDBUF,R0                ; добавляем адрес начала буфера
         CLR   R1
         MOVB  (R0),R1                   ; загружаем текущий байт из буфера
90$:
         MTPS   #0                       ; открываем прерывания
         RETURN
;*****************************************************************
;*  Обработка отпускания кнопок-модификаторов
;*****************************************************************
KBSTDOFF:
         CMPB  R1,#24                   ; правый CTRL
         BNE   14$
         BIC   #KB$LCTRL,KBFLAG
14$:
         CMPB  R1,#22                   ; Левый SHIFT
         BNE   18$
         BIC   #KB$LSHIFT,KBFLAG
18$:
         CMPB  R1,#131                  ; Правый SHIFT
         BNE   20$
         BIC   #KB$RSHIFT,KBFLAG
20$:
         RETURN

;*****************************************************************
;*  Обработка нажатия кнопок-модификаторов
;*****************************************************************
KBMODON:
         CMPB   R1,#24                   ; левый CTRL
         BNE    14$
         BIS    #KB$LCTRL,KBFLAG
         JMP 	98$
14$:
         CMPB   R1,#22                   ; Левый SHIFT
         BNE    18$
         BIS	#KB$LSHIFT,KBFLAG
         JMP 	98$
18$:
         CMPB   R1,#131                  ; Правый SHIFT
         BNE    81$
         BIS    #KB$RSHIFT,KBFLAG
         JMP    98$
81$:
         CMPB   R1,#176                  ; Scroll lock
         BNE    200$
         BIS    #KB$SCR,KBFLAG
         JMP    98$
200$:
         CMPB 	R1,#7	         	 ; F12 - 24/40 строк
         BNE    400$
         CALL   CLSCREEN             ; перед переключением чистим экранный буфер
         BIT 	#ST$L38,SYSFLAG      
         BEQ    54$
;     переход в режим 24 строк 
         BIC 	#ST$L38,SYSFLAG     ; системный флаг
         BIC    #VC$L38,@#VTCSR     ; бит регистра управления
         MOV    #VTOP24,VBUFTOP     ; верхняя граница видеобуфера
         JMP    98$
;     переход в режим 38 строк 
54$:	 BIS 	#ST$L38,SYSFLAG	    ; системный флаг
         BIS    #VC$L38,@#VTCSR     ; бит регистра управления
         MOV    #VTOP40,VBUFTOP     ; верхняя граница видеобуфера
         JMP    98$
400$:         
        CMPB 	R1,#14	         	 ; F4 - система команд VT52/15ИЭ
        BNE	    30$
        MOV     #ST$MODE,R1
        XOR 	R1,SYSFLAG
        BIC     #<ST$HLD!ST$WAIT>,SYSFLAG   ; при переключении отключаем режим HOLD SCREEN
        BR	    98$
30$:
        CMPB 	R1,#170	         	 ; F11 - KOI7
        BNE	    300$
        BIT     #KB$KOI7,KBFLAG
        BNE     35$
; переход rus/lat -> koi7          
        BIS     #KB$KOI7,KBFLAG    ;  поднимаем флаг кои7
        BIC     #KB$CAPS,KBFLAG    ;  отключаем капслок - включается латинский регистр
        BR      98$
35$:        
; переход koi7 -> rus/lat        
        BIC     #KB$KOI7,KBFLAG  ; снимаем флаг кои7
        BIS     #KB$CAPS,KBFLAG  ; включаем капслок - большие буквы
        BIC     #KB$LANG,KBFLAG  ; по умолчанию режим LAT, латинские буквы
        BR	    98$
300$:
        CMPB    R1,#21              ; левый ALT - RUS/LAT
        BNE     140$
		  BIT		 #KB$LANG,KBFLAG   ; проверяем текущий регистр
		  BNE		 308$              ; текущий - русский
; переход лат -> рус
		  MOV		 #16,R0    ; 16 - русский регистр
		  BR		 309$
308$:		  
; переход лат -> рус
		  MOV	    #17,R0    ; 17 - латинский регистр
309$:
		  CALL	 UTTOUT    ; отправляем код  в порт
        BR      98$
140$:
        CMPB 	R1,#3	         	 ; F5 - скорость--
        BNE	    150$
        DEC     SPEED
155$:
; установка новой скорости в регистр управления
        MOV     SPEED,R1       ; новый индекс скорости 
        BIC     #177770,R1     ; выделяем значащие биты, заворачиваем при переполнении
        MOV     R1,SPEED       ; обновляем локально сохраненный индекс  
        MOV     @#VTCSR,R0     
        SWAB    R0
        BIC     #7,R0
        BISB    R1,R0
        SWAB    R0
        MOV     R0,@#VTCSR
        BR      98$
        
150$:        
        CMPB 	R1,#13	         	 ; F6 - скорость++
        BNE	    40$
        INC     SPEED
        BR      155$

40$:
        CMPB 	R1,#130	         	 ; CAPS LOCK
        BNE	    130$
        MOV 	#KB$CAPS,R1
        XOR 	R1,KBFLAG
        BR      98$
130$:
        CMPB 	R1,#203	         	 ; F7 - форма курсора
        BNE	    250$
        MOV     #VC$FCUR,R1          
        XOR     R1,@#VTCSR           ; инвертируем бит формы курсора
        BR	    98$

250$:
        CMPB 	R1,#12	         	 ; F8 - мерцание курсора
        BNE	    190$
        MOV     #ST$BLINK,R1          
        XOR     R1,SYSFLAG            ; инвертируем флаг мерцания
        BIS     #VC$VCUR,@#VTCSR     ; делаем курсор видимым
        BR	    98$

190$:
        CMPB 	R1,#9.	         	 ; F10 - Online
        BNE	    330$
        BIT 	#ST$ONL,SYSFLAG
        BEQ	    53$
        BIC 	#ST$ONL,SYSFLAG
        BIC     #VC$ONL,@#VTCSR
        BR	    98$
53$:	
        BIS 	#ST$ONL,SYSFLAG	 
        BIS     #VC$ONL,@#VTCSR
        BR      98$
        
330$:   
        CMPB    R1,#1               ; F9 - отключение звука
        BNE     99$
        MOV     #ST$MUT,R1
        XOR     R1,SYSFLAG
; выход при обработанном коде
98$:
        CLC
        RETURN
; выход, если код не обработан        
99$:
        SEC
        RETURN

;*****************************************************************
;*  Обработка двухбайтовых кодов при нажатии управляющих кнопок
;*****************************************************************
KBEXON:
         CMPB   R1,#24                   ; правый CTRL
         BNE    10$
         BIS    #KB$RCTRL,KBFLAG
10$:
         CMPB   R1,#21                   ; правый ALT - LF
         BNE    20$
         MOV    #LF,R0       ; выводим код LF в порт
         CALL   UTTOUT
20$:
         RETURN

;********************************************************************
;*  Обработка двухбайтовых кодов при отпускании управляющих кнопок
;********************************************************************
KBEXOFF:
         CMPB   R1,#24                   ; правый CTRL
         BNE    10$
         BIC    #KB$RCTRL,KBFLAG
10$:	 RETURN
         
         
;*****************************************************************
;* Обработка двухбайтовых расширенных кодов E0 xx
;*****************************************************************
KB2B:
         BIT   	#KB$OFF,KBFLAG        ; установлен режим расширенного отпускания? 
         BEQ   	120$                  ; нет

; режим расширенного отпускания 

         CALL	KBEXOFF		 ; обрабатываем расширенные коды отпускания
         BR    	98$  
         
; режим расширенного нажатия

120$:	 
        CMPB 	R1,#P$KBOFF      ; Это префикс отпускания?
        BNE	    130$             ; нет
        BIS	    #KB$OFF,KBFLAG   ; устанавливаем флаг отпускания
        RETURN
130$:	 
        CALL 	KBEXON 		; обрабатываем префиксные кнопки
        BIT     #ST$MODE,SYSFLAG ; текущая система команд
        BEQ     10$
        
; режим 15ИЭ

        CALL    IECODES
        BR      98$

; режим VT52

10$:        
        MOV 	#EVESC,R2  ; таблица ESC-последовательностей для двухбайтовых сканкодов
        CALL 	KBESC
98$:
        BIC   	#<KB$EXT!KB$OFF>,KBFLAG ; снимаем флаг расширенных кодов и отпускания
        RETURN        

;*************************************************************************************
;* Обработка нажатия управляющих кнопок режима 15ИЭ (двухбайтовые коды E0 xx
;*************************************************************************************
IECODES:
        MOV     #EIKEYS,R2   ; таблица кодов
10$:
        MOVB    (R2)+,R0     ; сканкод из таблицы
        TSTB    R0           ; 0 - конец таблицы
        BEQ     100$
        CMPB    R0,R1        ; это наш сканкод?
        BNE     20$          ; нет
        MOVB    (R2),R0      ; выбираем управляющий код из таблицы
        CALL    UTTOUT       ; и выводим его в порт
        CLC                  ; признак обработанного кода
        RETURN
20$:
        INC     R2           ; переходим к следующей записи таблицы
        BR      10$          
100$:
        SEC                  ; признак необработанного сканкода
        RETURN

        
;*****************************************************************
;* Обработка кодов, генерирующих ESC-последовательности
;* R1 - сканкод
;* R2 - адрес таблицы кодов
;*  --> C=0 код обработан 
;*      C=1 код не найден
;*****************************************************************
KBESC:
        CMPB 	(R2),R1      ; сканкод из таблицы - наш код?
        BNE	    50$          ; нет
        INC	    R2           ; R2 -> esc-последовательность из таблицы
        BIT 	#KB$ALT,KBFLAG ; мы в режиме альтернативной клавиатуры?
        BEQ 	10$            ; нет 
        ADD 	#2,R2          ; сдвигаем указатель к таблице альтернативных esc-последовательностей
10$:	CALL 	ESCSEND      ; выводим последовательность в порт
        CLC               ; код обработан
        RETURN
50$:
        ADD     #5,R2     ; переходим к следующему элементу таблицы
        TSTB 	(R2)      ; конец таблицы?
        BNE	    KBESC     ; нет
        SEC               ; код не обработан
        RETURN
	 

;*****************************************************************
;* Обработка байтов, поступающих из порта клавиатуры
;*****************************************************************
KBIN:
        CALL    KBLOAD		   ; получаем сканкод с клавиатуры -> R1
        TST 	R0
        BNE 	199$		
        CLC			       ; пока с клавиатуры ничего не поступало
        RETURN

199$:
        BIT 	#KB$EXT,KBFLAG  ; идет обработка расширенных кодов?
        BEQ	    100$            ; нет
        CALL 	KB2B           ; обрабатываем двухбайтовые сканкоды  
        BR	    KBEXIT

; Обработка однобайтовых кодов	

100$:	
        BIT 	#KB$OFF,KBFLAG    ; мы находимся в режиме отпускания?
        BEQ	    120$		      ; нет
        CALL	KBSTDOFF          ; обрабатываем отпускания
        BIC 	#KB$OFF,KBFLAG
        BR	    KBEXIT

120$:	
        CMPB 	R1,#P$KBEX       ; принят расширенный префикс Е0?
        BNE 	130$
        BIS	    #KB$EXT,KBFLAG    ; поднмаем флаг для принятия второго кода последовательности
        BR	    KBEXIT
	 
130$:
        CMPB 	R1,#P$KBOFF 	  ; принят код отпускания?
        BNE	    150$		      ; нет
        BIS	    #KB$OFF,KBFLAG	  ; поднимаем флаг стандартного отпускания
        BR	    KBEXIT			

; Обработка однобайтовых сканкодов нажатия

150$:	 
         MOV 	#SVESC,R2         ; таблица управляющих однобайтовых кодов
         CALL 	KBESC             ; попытка обработки такого кода 
         BCC 	KBEXIT            ; Код обработан - на выход
                  
         CALL   KBMODON           ; обрабатываем коды кнопок-модификаторов 
         BCC 	KBEXIT               ; модификатор обработан

         CMP 	R1,#167           ; коды выше 166 (ESC) не обрабатываем
         BGE 	KBEXIT              

; Поиск сканкода в таблице	  
155$:
         ASH     #3,R1             ; умножаем на размер записи таблицы (8 байт) - получаем смещение до описателя нашего сканкода
         ADD	 #SCTAB,R1         ; R1 => описатель данного сканкода

; Проверка режима ctrl         
         BIT 	 #<KB$LCTRL!KB$RCTRL>,KBFLAG ; CTRL нажат?
         BEQ 	 60$               ; нет
         ADD	 #ST.CTRL,R1       ; выбираем поле ctrl таблицы
         MOVB 	 (R1),R0           ; выбираем байт из таблицы
         CMPB    #377,R0           ; такого ctrl-кода не существует?
         BEQ     KBEXIT            ; да - прекращаем обработку                                  
         BR	     400$              ; иначе выводим код в интерфейс                           
60$:
;
;  Подготовка слова состояния клавиатуры для поиска в таблице вариантов сканкода
;
         CLR     R0                 ; сюда будут собираться биты режима
         BIT 	 #KB$KOI7,KBFLAG                                 
         BNE 	 310$                ; текущий режим - KOI7   
         BIT     #KB$LANG,KBFLAG
         BEQ     10$                ; режим латинских букв
; режим русских букв         
         BIS     #KM.RUS,R0         ; поднимаем бит русского режима
         BR      320$               ; идем проверять флаг CR
; режим KOI7         
310$:
         BIS     #KM.KOI,R0         ; поднимаем бит KOI7
320$:         
         BITB    #F$CR,ST.FLAG(R1)  ; проверка флага CR
         BEQ     1125$              ; 0
         BR      1130$              ; 1
; режим латинских букв         
10$: 
         BITB    #F$CL,ST.FLAG(R1)  ; проверяем флаг CL
         BEQ     1125$              ; 0
; формирование бита CLR на основе предыдущего анализа флагов CR/CL         
1130$:         
         BIS     #KM.CLR,R0
1125$:
         BIT 	 #<KB$LSHIFT!KB$RSHIFT>,KBFLAG   ; нажат SHIFT ?
         BEQ 	 15$               ; нет
         BIS     #KM.SHIFT,R0      ; поднимаем бит shift
15$:
         BIT 	 #KB$CAPS,KBFLAG   ; режим CAPS?
         BEQ	 20$               ; нет
         BIS     #KM.CAPS,R0       ; поднимаем бит caps
20$:
         CLR     R2
         ADD     #KSELTAB,R0      ; добавляем адрес таблицы выбора к полученному битовому полю
         MOVB    (R0),R2          ; выбираем из таблицы номер используемой колонки сканкодов
         
;++++++ отладочный код - выводит номер колонки в 5 знакоместо служебной строки +++++         
;         MOV     R2,R0
;         ADD     #'0,R0
;         MOVB    R0,@#VBUF+5
;+++++++++++         
         
         ADD     R2,R1           ; R1 теперь указывает на код символа, соответствующего нашему сканкоду
         MOVB 	 (R1),R0         ; выбираем этот байт из таблицы
         TSTB 	 R0              ; Коды 00 - это отсутствие символа, связанного со сканкодом
         BEQ	 KBEXIT          ; нулевые коды игнорируем 
400$:
         CALL 	 UTTOUT          ; выводим полученный знак в порт
KBEXIT:         
         SEC                     ; признак обработанного сканкода
         RETURN
         
;******************************************************
;* Вывод байта в порт UART
;******************************************************
UTTOUT:
         BIT	#200,@#TTOUTCSR    ; ждем готовности передатчика
         BEQ	UTTOUT
         MOVB	R0,@#TTOUTDAT      ; выводим байтв регистр данных
         RETURN

;******************************************************
;* Вывод ESC-последовательности в порт UART 
;* Последовательность состоит из 1 или 2 байтов
;*   R2 - адрес массива из одного или двух байтов,
;*        вторые нулевые байты не выводятся
;*
;*      Если первый байт имеет единичный старший бит,
;*      то выводится только он, без ESC
;******************************************************
ESCSEND:
         BITB	#200,(R2)       ; флаг вывода без ESC установлен
         BEQ 	10$             ; нет
         MOVB   (R2),R0         ; код из таблицы
         BICB	#200,R0         ; снимаем флаговый бит
         CALL 	UTTOUT          ; и выводим код в порт
         RETURN
10$:         
         MOVB	#ESC,R0         ; выводим ESC
         CALL	UTTOUT
         MOVB	(R2)+,R0        ; выводим первый байт из таблицы
         CALL 	UTTOUT
         MOVB	(R2)+,R0        ; второй байт из таблицы
         BEQ	99$             ; код 0 не выводим
         CALL 	UTTOUT          
99$:	 
         RETURN
         
;*************************************************************
;* Обработчик прерывания от приемника UART DL11
;*************************************************************
RXIRQ:
         TSTB 	@#TTINCSR              ; Проверяем бит 7 CSR - признак наличия принятого байта
         BPL 	90$                    ; PL- разряд равен 0, нет принятых данных
         
         MOV 	R0,-(SP)               
         MOV 	R1,-(SP)               

         MOV 	DBUFSTORE,R0           ; Указатель записи
         MOV 	DBUFLOAD,R1            ; Указатель чтения
         INC 	R0                     ; продвигаем указатель записи
         BIC 	#177600,R0
         CMP 	R0,R1                  ; Указатели совпадают?
         BEQ 	80$                    ; Да - переполнение буфера, отбрасываем принятый байт

         MOV 	R0,DBUFSTORE           ; сохраняем указатель
         MOVB 	@#TTINDAT,R1             ; Принимаем байт из регистра данных UART
         ADD 	#DBUF,R0               ; Добавляем адрес буфера
         MOVB 	R1,(R0)                ; сохраняем байт в буфер

80$:
         MOV 	(SP)+,R1               
         MOV 	(SP)+,R0               
90$:
         MOV 	#100,@#TTINCSR             ; Поднимаем бит разрешения прерывания
         RTI

;********************************************
;* Обработка прерывания от передатчика UART
;********************************************
TXIRQ:
         RTI

;**************************************************
;* Обработка прерывания от приемника клавиатуры
;**************************************************
KBRIRQ:
         TSTB 	@#KBCSR                ; Проверяем бит 7 CSR - признак наличия принятого байта
         BPL 	90$                      ; PL- разряд равен 0, нет принятых данных
         
         MOV 	R0,-(SP)                 
         MOV 	R1,-(SP)                 
         MOV 	R2,-(SP)                 
         MOVB 	@#KBDAT,R0             ; Принимаем байт из регистра данных 
         TST    KBTIMER                ; таймер задержки обнулен?
         BNE    10$                    ; нет - обходим запись байта в буфер
         CALL	KBSTORE                ; иначе записываем сканкод
10$:         
         MOV 	(SP)+,R2                 
         MOV 	(SP)+,R1                 
         MOV 	(SP)+,R0                 
90$:
         MOV 	#100,@#KBCSR              ; Поднимаем бит разрешения прерывания
         RTI

;********************************************
;* Обработка прерывания от таймера
;********************************************
TMRIRQ:
        INCB    TTICK            ; счетчик тактов таймера
        CMPB    TTICK,#50.       ; 50 тактов - секунда
        BNE     600$             ; еще не набралось 50 тактов
        CLRB    TTICK            ; заворачиваем счетчик тактов
;
;  Счетчики времени работы терминала
; 
        INCB    TSEC             ; секунды
        CMPB    TSEC,#60.        ; считаем до 60
        BNE     500$
        CLRB    TSEC
        
        INCB    TMIN            ; минуты
        CMPB    TMIN,#60.
        BNE     500$
        CLRB    TMIN
        
        INCB    THOUR           ; часы
        CMPB    THOUR,#100.     ; считаем до 100
        BNE     500$
        CLRB    THOUR
500$:
; 
; вывод текущего времени в строку состояния
;
        MOV     R0,-(SP)
        MOV     R1,-(SP)
        MOV     R2,-(SP)
        MOV     #RL.TIM,R2      ; позиция часов в строке состояния
        MOVB    THOUR,R1        ; выводим час
        CALL    PDEC
        MOVB    #':,(R2)+
        MOVB    TMIN,R1         ; минуты
        CALL    PDEC
        MOVB    #':,(R2)+
        MOVB    TSEC,R1         ; секунды
        CALL    PDEC
        MOV     (SP)+,R2
        MOV     (SP)+,R1
        MOV     (SP)+,R0
600$:
;
; Реализация мерцания курсора
; 
        BIT     #ST$BLINK,SYSFLAG    ; курсор не мерцает?
        BNE     700$                ; да, обходим таймер
        INC     CTIMER              ; таймер мерцания
        BIC     #177760,CTIMER      ; считает от 0 до 15
        BNE     700$                ; пока не досчитал
        MOV     R1,-(SP)
        MOV     #VC$VCUR,R1         
        XOR     R1,@#VTCSR          ; переключаем видимость курсора
        MOV     (SP)+,R1
;
;  Таймер звукового сигнала
;
700$:   
        TST     STIMER              ; таймер работает?
        BEQ     800$                ; нет
        DEC     STIMER              ; уменьшаем счетчик
        BNE     800$                ; еще не 0
        BIC     #VC$SND,@#VTCSR     ; доехали до 0 - отключаем звук
800$:        
;
; Таймер задержки запуска клавиатуры
;
        TST     KBTIMER
        BEQ     900$                ; считаем до 0, счетчик не перезапускается
        DEC     KBTIMER
;
; Таймер мерцания символов
;
900$:
        TST     FLTIMER             ; досчитали до 0?
        BNE     950$                ; нет
        MOV     #10.,FLTIMER        ; перезапускаем таймер 
        MOV     R0,-(SP)
        MOV     #VC$FLASH,R0        ; бит сигнала мерцания
        XOR     R0,@#VTCSR          ; инвертируем его в регистре управления
        MOV     (SP)+,R0
950$:
        DEC     FLTIMER             ; просто уменьшаем счетчик таймера
1000$:        
        RTI

;*************************************************************
;*  Преобразование байта в 2 десятичные цифры в коде ascii
;*
;*    R1  - байт-аргумент
;*    R2  - адрес буфера результата
;*************************************************************
PDEC:
        BIC     #177600,R1      ; выделяем младшие 7 бит
        CLR     R0
        DIV     #10.,R0         ; делим (R0:R1) на 10
        ADD     #60,R0          ; частное - переводим в цифру
        MOVB    R0,(R2)+        ; выводим в выходную строку 
        ADD     #60,R1          ; остаток
        MOVB    R1,(R2)+
        RETURN
        
;******************************************************
;*  Запись байта из R0 в кольцевой буфер клавиатуры
;******************************************************
KBSTORE:
         MOV 	KBUFSTORE,R2          ; Указатель записи
         MOV 	KBUFLOAD,R1           ; Указатель чтения
         INC 	R2                    ; продвигаем указатель записи
         BIC 	#177700,R2		      ; заворот по границе буфера
         CMP 	R2,R1                 ; Указатели совпадают?
         BEQ 	80$                   ; Да - переполнение буфера, отбрасываем принятый байт
         MOV 	R2,KBUFSTORE          ; сохраняем указатель
         ADD 	#KBDBUF,R2            ; Добавляем адрес буфера
         MOVB 	R0,(R2)               ; сохраняем байт в буфер

80$:     RETURN
         
;==================================================
;  Сегмент данных
;==================================================
SPEED:     .WORD   0   ; индекс скорости интерфейса
;
; Верхняя граница видеобуфера в текущем режиме
;
VBUFTOP:   .WORD  0
;
; Указатели кольцевых буферов
;
DBUFSTORE: .WORD 0
DBUFLOAD:  .WORD 0
KBUFSTORE: .WORD 0
KBUFLOAD:  .WORD 0
;
; Флаги состояния клавиатуры
;
KBFLAG:	   .WORD	0
KB$OFF=1                   ; 0 - Признак начала последовательности отпускания (код F0)
KB$EXT=2                   ; 1 - Признак расширенного кода E0
KB$ALT=4	           	   ; 2 - Режим альтернативной клавиатуры
KB$LCTRL=10                ; 3 - левый CTRL нажат
KB$RCTRL=20                ; 4 - правый CTRL нажат
KB$LSHIFT=40               ; 5 - Левый SHIFT нажат                      
KB$RSHIFT=100              ; 6 - Правый SHIFT нажат
KB$CAPS=200		           ; 7 - Режим CAPS LOCK
KB$SCR=400                 ; 8 - Scroll Lock нажат
KB$KOI7=1000		       ; 9 - 0 - режим R/L (большие и малые русские-латинские)
                           ;     1 - КОИ7 (только большие русские-латинские)
KB$LANG=2000               ; 10 - текущий языковый набор, в режиме koi7 игнорируется
                           ;     0 - латинские буквы
                           ;     1 - русские буквы
;                           
; Флаги управления системой
;
SYSFLAG:   .WORD    0
ST$L38=1 		           ; 0 - Режим 38 строк
ST$MUT=2                   ; 1 - отключение звукового сигнала
ST$ONL=4                   ; 2 - Режим Online
ST$GRF=10                  ; 3 - псевдографический режим
ST$HLD=20                  ; 4 - hold screen
ST$WAIT=40                 ; 5 - вывод на экран приостановлен
ST$BLINK=100               ; 6 - режим курсора, 0 - мигает, 1 - не мигает
ST$MODE=200                ; 7 - система команд: 0 - VT52, 1 - 15иэ-00-013

; адрес курсора в видеобуфере
TCUR:	 .WORD	0		

; флаги обработки ESC-последовательностей

ESCFLAG: .WORD  0		
ESCY0L:	 .WORD  0		   ; параметр 1 команды ESC-Y
ESCY1C:	 .WORD  0          ; параметр 2 команды ESC-Y

ESC$ON=1   ; начало ESC-последовательности  
ESC$Y0=2;  ; начало ESC-Y-последовательности
ESC$Y1=4;  ; продолжение ESC-Y-последовательности

; Счетчик сдвигов строк перед задержкой hold screen
SDELAY:  .WORD  0

; Счетчики подсистемы таймера
TTICK:   .BYTE  0    ; счетчик тактов до секунды
TSEC:    .BYTE  0    ; секунды
TMIN:    .BYTE  0    ; минуты
THOUR:   .BYTE  0    ; часы
CTIMER:  .WORD  0    ; таймер мерцания курсора
STIMER:  .WORD  0    ; таймер длительности звукового сигнала
KBTIMER: .WORD  0    ; таймер задержки приема данных с клавиатуры
FLTIMER: .WORD  0    ; таймер мерцания символов

; скорости интерфйса
RSPEED:   .ASCII   /  1200/
          .ASCII   /  2400/
          .ASCII   /  4800/
          .ASCII   /  9600/
          .ASCII   / 19200/
          .ASCII   / 38400/
          .ASCII   / 57600/
          .ASCII   /115200/

; Индикаторы служебной строки
RLI$VT52: .ASCIZ   /VT52/
RLI$15:   .ASCIZ   /15/<351><374>   ; 15ИЭ 
RLI$ONL:  .ASCIZ   /LINE /
RLI$LOC:  .ASCIZ   /LOCAL/
RLI$CAP:  .ASCIZ   /CAPS/
RLI$ALT:  .ASCIZ   /ALT/
RLI$L38:  .ASCIZ   /L38/
RLI$L24:  .ASCIZ   /L24/
RLI$KOI:  .ASCIZ   /KOI7/
RLI$RUS:  .ASCIZ   /RUS /
RLI$LAT:  .ASCIZ   /LAT /
RLI$HLD:  .ASCIZ   /HOLD/
RLI$SCR:  .ASCIZ   /WAIT/
RLI$MUT:  .ASCIZ   /MUTE/
RLI$BLK:  .ASCIZ   /     /

          .EVEN


;******************************************************
; Макрос для генерации таблиц описания спецкнопок
;
;    CODE  - сканкод кнопки
;    *SEQ1 - первый байт последовательности
;    *SEQ2 - второй байт последовательности
;    Р - основной режим
;    А - альтернативный режим
;******************************************************
	  .MACRO   FKEY   CODE,PSEQ1,PSEQ2,ASEQ1,ASEQ2
	  .BYTE	   CODE              ; сканкод
	  .BYTE	   PSEQ1             ; первый байт основной последовательности
      .IF 	   NB, <PSEQ2>				
	  .BYTE	   PSEQ2             ; второй основной байт, если есть
	  .IFF						
	  .BYTE	   0                 ; если нет - 0
	  .ENDC 
	  .IF 	   NB, <ASEQ1>
	  .BYTE	   ASEQ1             ; первый байт альтернативной последовательности
	  .IFF
	  .BYTE	   PSEQ1             ; если его нет, то он совпадает с первым основным байтом
	  .ENDC
      .IF 	   NB, <ASEQ2>				
	  .BYTE	   ASEQ2             ; второй альтернативный байт если есть
	  .IFF						
	  .BYTE	   0                 ; если нет - 0
	  .ENDC 
	  .ENDM    FKEY
	  
;***********************************************************************************
;*  Таблица ESC-последовательностей, генерируемых спецкнопками.  Режим VT52
;*                  Сканкоды E0 xx
;***********************************************************************************
EVESC:
      FKEY  112,'Q		   ; PF2 - /
      FKEY  165,'A		   ; стрелка вверх
      FKEY  162,'B		   ; стрелка вниз
      FKEY  164,'C                 ; стрелка вправо
      FKEY  153,'D                 ; стрелка влево
      FKEY  132,<CR!200>,,77,115   ; kpad enter
      .BYTE 0
      
;***********************************************************************************
;*  Таблица ESC-последовательностей, генерируемых спецкнопками. Режим VT52
;*                  Сканкоды без E0
;***********************************************************************************
SVESC:
      FKEY  167,'P                 ; PF1 - Numlock
      FKEY  174,'R		           ; PF3 - *
      FKEY  160,<'0!200>,,77,160   ; kpad 0
      FKEY  151,<'1!200>,,77,161   ; kpad 1
      FKEY  162,<'2!200>,,77,162   ; kpad 2
      FKEY  172,<'3!200>,,77,163   ; kpad 3
      FKEY  153,<'4!200>,,77,164   ; kpad 4
      FKEY  163,<'5!200>,,77,165   ; kpad 5
      FKEY  164,<'6!200>,,77,166   ; kpad 6
      FKEY  154,<'7!200>,,77,167   ; kpad 7
      FKEY  165,<'8!200>,,77,170   ; kpad 8
      FKEY  175,<'9!200>,,77,171   ; kpad 9
      FKEY  161,<'.!200>,,77,156   ; kpad .
      FKEY  171,'B                 ; kpad + == down
      FKEY  173,'A                 ; kpad - == up
      .BYTE 0
 
;***********************************************************************************
;*  Таблица кодов управляющих клавиш режима 15ИЭ
;*                  Сканкоды E0 xx
;***********************************************************************************
EIKEYS:
;          сканкод  упр.код
    .BYTE    165,    034     ; курсор вверх
    .BYTE    162,    035     ; курсор вниз
    .BYTE    153,    032     ; курсор влево
    .BYTE    164,    031     ; курсор вправо
    .BYTE    154,    010     ; Home - курсор в начало экрана
    .BYTE    172,    026     ; PgDn - сдвиг текста вниз
    .BYTE    175,    022     ; PgUp - сдвиг текста вверх
    .BYTE    160,    023     ; Ins  - размыкание строки
    .BYTE    161,    024     ; Del  - смыкание строки
    .BYTE    0
    
      .EVEN

; Биты состояния клавиатуры для формирования индекса варианта перекодировки
KM.CLR   = 1
KM.SHIFT = 2
KM.CAPS  = 4
KM.KOI   = 10
KM.RUS   = 20
;
;  Таблица выбора варианта перекодировки сканкода в зависимости от режима работы клавиатуры
KSELTAB: 
;
;колонка sctab           RUS    кои-7     caps lk   shift   F$C(L!R) 
;                      KM.RUS  KM.KOI     KM.CAPS KM.SHIFT  KM.CLR          ##d  ##o
; ---- режим LAT --------------------------------------------------------------------- 
.byte   ST.LL       ;    0       0           0       0        0             0     0
.byte   ST.LL       ;    0       0           0       0        1             1     1
.byte   ST.LU       ;    0       0           0       1        0             2     2
.byte   ST.LU       ;    0       0           0       1        1             3     3  
.byte   ST.LL       ;    0       0           1       0        0             4     4
.byte   ST.LU       ;    0       0           1       0        1             5     5
.byte   ST.LU       ;    0       0           1       1        0             6     6
.byte   ST.LL       ;    0       0           1       1        1             7     7
; ---- режим KOI-7-------------------------------------------------------------------- 
.byte   ST.KL       ;    0       1           0       0        0             8     10
.byte   ST.KL       ;    0       1           0       0        1             9     11
.byte   ST.KR       ;    0       1           0       1        0             10    12 
.byte   ST.KR       ;    0       1           0       1        1             11    13
.byte   ST.KL       ;    0       1           1       0        0             12    14
.byte   ST.KR       ;    0       1           1       0        1             13    15 
.byte   ST.KR       ;    0       1           1       1        0             14    16
.byte   ST.KL       ;    0       1           1       1        1             15    17
; ---- режим RUS ---------------------------------------------------------------------
.byte   ST.RU       ;    1       0           0       0        0             16    20
.byte   ST.RU       ;    1       0           0       0        1             17    21
.byte   ST.RL       ;    1       0           0       1        0             18    22
.byte   ST.RL       ;    1       0           0       1        1             19    23
.byte   ST.RU       ;    1       0           1       0        0             20    24 
.byte   ST.RL       ;    1       0           1       0        1             21    25
.byte   ST.RL       ;    1       0           1       1        0             22    26
.byte   ST.RU       ;    1       0           1       1        1             23    27

;************************************************************************************
;* Таблица перекодировки сканкодов 
;
;  --- Варианты состояния клавиатуры:
; LAT-L - латинские малые буквы
; LAT-U - латинские большие буквы (с CAPS и shift)
; KOI7-L - русские буквы в режиме koi7
; KOI7-U - латинские буквы в режиме koi7 (с CAPS и shift)
; RUS-L - малые русские буквы
; RUS-U - большие русские буквы
; ctrl  - коды, генерируемые при нажатой кнопке CTRL
; flag  - флаги:
F$CL=1 ;- в латинском регистре CAPS влияет на кнопку
F$CR=2 ;- в русском регистре CAPS влияет на кнопку
;
ST.LL  = 0    ; Номер колонки LAT-L
ST.LU  = 1    ; Номер колонки LAT-U
ST.KR  = 2    ; Номер колонки KOI-R
ST.KL  = 3    ; Номер колонки KOI-L
ST.RL  = 4    ; Номер колонки RUS-L
ST.RU  = 5    ; Номер колонки RUS-U
ST.CTRL= 6    ; Номер колонки ctrl
ST.FLAG= 7    ; Номер колонки Flag
;*************************************************************************************
SCTAB: ;        0      1         2        3       4      5     6       7     обрабатываемый сканкод
;             Lat-L   LAT-U    KOI7-R   KOI7-L  RUS-L  RUS-U  ctrl    flag   
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 00 - 
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 01 - f9
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 02 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 03 - f5
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 04 - f3
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 05 - f1
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 06 - f2
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 07 - f12
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 08 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 09 - f10
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 0a - f8
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 0b - f6
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 0c - f4
         .BYTE  11 ,  11   ,    11 ,     11  ,   11 ,   11 ,   377   ,   0            ; 0d - tab
         .BYTE  '` ,   '~  ,    ', ,     '.  ,   ', ,   '. ,   377   ,   0            ; 0e - ` ~
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 0f -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 10 -
         .BYTE  12 ,   12  ,    12 ,     12  ,   12 ,   12 ,   377   ,   0            ; 11 - l-alt
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 12 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 13 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 14 -
         .BYTE 'q  ,   'Q  ,   'j  ,    'Q   ,  'J  ,  'j  ,   21    ,  <F$CL!F$CR>   ; 15 - Q Й
         .BYTE '1  ,   '!  ,   '!  ,    '1   ,  '!  ,  '1  ,   377   ,   0            ; 16 - 1 !
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 17 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 18 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 19 -
         .BYTE 'z  ,   'Z  ,   'q  ,    'Z   ,  'Q  ,  'q  ,   32    ,   <F$CL!F$CR>  ; 1a - Z Я
         .BYTE 's  ,   'S  ,   'y  ,    'S   ,  'Y  ,  'y  ,   23    ,   <F$CL!F$CR>  ; 1b - S Ы
         .BYTE 'a  ,   'A  ,   'f  ,    'A   ,  'F  ,  'f  ,   1     ,   <F$CL!F$CR>  ; 1c - A Ф
         .BYTE 'w  ,   'W  ,   'c  ,    'W   ,  'C  ,  'c  ,   27    ,   <F$CL!F$CR>  ; 1d - W Ц
         .BYTE '2  ,   '@  ,   '@  ,    '2   ,  042 ,  '2  ,   0     ,   0            ; 1e - 2 @
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 1f -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 20 -
         .BYTE 'c  ,   'C  ,   's  ,    'C   ,  'S  ,  's  ,   3     ,   <F$CL!F$CR>  ; 21 - С С
         .BYTE 'x  ,   'X  ,   '~  ,    'X   ,  '^  ,  '~  ,   30    ,   <F$CL!F$CR>  ; 22 - X Ч
         .BYTE 'd  ,   'D  ,   'w  ,    'D   ,  'W  ,  'w  ,   4     ,   <F$CL!F$CR>  ; 23 - D В
         .BYTE 'e  ,   'E  ,   'u  ,    'E   ,  'U  ,  'u  ,   5     ,   <F$CL!F$CR>  ; 24 - E У
         .BYTE '4  ,   '$  ,   '$  ,    '4   ,  '$  ,  '4  ,   377   ,   0            ; 25 - 4 $
         .BYTE '3  ,   '#  ,   '#  ,    '3   ,  '#  ,  '3  ,   377   ,   0            ; 26 - 3 #
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 27 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 28 -
         .BYTE  40 ,  40   ,    40 ,     40  ,   40 ,   40 ,   377   ,   0            ; 29 - space
         .BYTE 'v  ,   'V  ,   'm  ,    'V   ,  'M  ,  'm  ,   26    ,   <F$CL!F$CR>  ; 2a - V М
         .BYTE 'f  ,   'F  ,   'a  ,    'F   ,  'A  ,  'a  ,   6     ,   <F$CL!F$CR>  ; 2b - F А
         .BYTE 't  ,   'T  ,   'e  ,    'T   ,  'E  ,  'e  ,   24    ,   <F$CL!F$CR>  ; 2c - T Е
         .BYTE 'r  ,   'R  ,   'k  ,    'R   ,  'K  ,  'k  ,   22    ,   <F$CL!F$CR>  ; 2d - R К
         .BYTE '5  ,   '%  ,   '%  ,    '5   ,  '%  ,  '5  ,   377   ,   0            ; 2e - 5 %
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 2f -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 30 -
         .BYTE 'n  ,   'N  ,   't  ,    'N   ,  'T  ,  't  ,   16    ,   <F$CL!F$CR>  ; 31 - N Т
         .BYTE 'b  ,   'B  ,   'i  ,    'B   ,  'I  ,  'i  ,   2     ,   <F$CL!F$CR>  ; 32 - B И
         .BYTE 'h  ,   'H  ,   'r  ,    'H   ,  'R  ,  'r  ,   10    ,   <F$CL!F$CR>  ; 33 - H Р
         .BYTE 'g  ,   'G  ,   'p  ,    'G   ,  'P  ,  'p  ,   7     ,   <F$CL!F$CR>  ; 34 - G П
         .BYTE 'y  ,   'Y  ,   'n  ,    'Y   ,  'N  ,  'n  ,   31    ,   <F$CL!F$CR>  ; 35 - Y Н 
         .BYTE '6  ,   '^  ,   '^  ,    '6   ,  '?  ,  '6  ,   36    ,   0            ; 36 - 6 ^
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 37 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 38 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 39 -
         .BYTE 'm  ,   'M  ,   'x  ,    'M   ,  'X  ,  'x  ,   15    ,   <F$CL!F$CR>  ; 3a - M Ь
         .BYTE 'j  ,   'J  ,   'o  ,    'J   ,  'o  ,  'o  ,   12    ,   <F$CL!F$CR>  ; 3b - J О
         .BYTE 'u  ,   'U  ,   'g  ,    'U   ,  'G  ,  'g  ,   25    ,   <F$CL!F$CR>  ; 3c - U Г
         .BYTE '7  ,   '&  ,   '&  ,    '7   ,  '&  ,  '7  ,   377   ,   0            ; 3d - 7 &
         .BYTE '8  ,   '*  ,   '*  ,    '8   ,  '*  ,  '8  ,   377   ,   0            ; 3e - 8 *
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 3f -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 40 -
         .BYTE ',  ,   '<  ,   'b  ,    '<   ,  'B  ,  'b  ,   377   ,   F$CR         ; 41 - ,< Б
         .BYTE 'k  ,   'K  ,   'l  ,    'K   ,  'L  ,  'l  ,   13    ,   <F$CL!F$CR>  ; 42 - K Л
         .BYTE 'i  ,   'I  ,   '{  ,    'I   ,  '[  ,  '{  ,   11    ,   <F$CL!F$CR>  ; 43 - I Ш
         .BYTE 'o  ,   'O  ,   '}  ,    'O   ,  ']  ,  '}  ,   17    ,   <F$CL!F$CR>  ; 44 - J О
         .BYTE '0  ,   ')  ,   ')  ,    '0   ,  ')  ,  '0  ,   377   ,   0            ; 45 - 0
         .BYTE '9  ,   '(  ,   '(  ,    '9   ,  '(  ,  '9  ,   377   ,   0            ; 46 - 9
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 47 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 48 -
         .BYTE '.  ,   '>  ,   '`  ,    '>   ,  '@  ,  '`  ,   377   ,   F$CR         ; 49 - .> Ю
         .BYTE  57 ,  '?   ,   ',  ,    '.   ,  '.  ,  ',  ,   377   ,   0            ; 4a - /,?
         .BYTE 'l  ,   'L  ,   'd  ,    'L   ,  'D  ,  'd  ,   14    ,   <F$CL!F$CR>  ; 4b - L Д
         .BYTE ';  ,   ':  ,   'v  ,    ':   ,  'V  ,  'v  ,   377   ,   F$CR         ; 4c - : ; Ж
         .BYTE 'p  ,   'P  ,   'z  ,    'P   ,  'Z  ,  'z  ,   20    ,   <F$CL!F$CR>  ; 4d - P З
         .BYTE '-  ,   '_  ,   '-  ,    '_   ,  '_  ,  '-  ,   37    ,   0            ; 4e - - _
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 4f -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 50 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 51 -
         .BYTE 047 ,   042 ,   174 ,    042  ,  134 ,  174 ,   377   ,   F$CR         ; 52 - "",' Э
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 53 -
         .BYTE '[  ,   '{  ,   'h  ,    '[   ,  'H  ,  'h  ,   32    ,   F$CR         ; 54 - [ { Х
         .BYTE '=  ,   '+  ,   '=  ,    '+   ,  '+  ,  '=  ,   377   ,   0            ; 55 - = +
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 56 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 57 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 58 - caps lock
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 59 - right shift
         .BYTE  15 ,   15  ,    15 ,     15  ,   15 ,   15 ,   377   ,   0            ; 5a - enter
         .BYTE ']  ,   '}  ,   ';  ,    ']   ,  ']  ,  ';  ,   35    ,   F$CR         ; 5b - ] } 
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 5c -
         .BYTE '\  ,   174 ,   '/  ,    '/   ,  '/  ,  '/  ,   34    ,   0            ; 5d - \ | 
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 5e -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 5f -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 60 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 61 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 62 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 63 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 64 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 65 -
         .BYTE  177,   177 ,    177,     177 ,   177,   177,   377   ,   0            ; 66 - backspace
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 67 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 68 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 69 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 6a -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 6b -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 6c -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 6d -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 6e -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 6f -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 70 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 71 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 72 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 73 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 74 -
         .BYTE  0  ,   0   ,    0  ,     0   ,   0  ,   0  ,   377   ,   0            ; 75 -
         .BYTE  33 ,   33  ,    33 ,     33  ,   33 ,   33 ,   377   ,   0            ; 76 - escape
         
	  .EVEN                                

;
; Кольцевой буфер выводимых на экран байтов
;
DBUF:  	   .BLKW  128.
;
; Кольцевой буфер клавиатуры
;
KBDBUF:    .BLKW  64.
	
	  .END  0
						  
